<html>
<body>
<input type="file" accept=".sm" id="upload" value="Upload From Computer" onclick="clearStartedParse()"><br>
<input type="button" value="Start Parse" onclick="go()"><br>
<span id="finish-parse-section"></span>
</body>
<script src="test.js"></script>
<script src="test_cases/felyslong/felyslong.js"></script>
<script>
var reader;
var startedParse;

function clearStartedParse() {
	document.getElementById("finish-parse-section").innerHTML = "";
	startedParse = undefined;
}

function go() {
	let upload = document.getElementById("upload");
	let file = upload.files[0];
	reader = new FileReader()
	reader.readAsText(file);
	reader.addEventListener('loadend', onFileLoaded);
}

function onFileLoaded() {
	let file = reader.result;
	startParse(file);
}

function startParse(file) {
	startedParse = parseMetaData(file);
	console.log(startedParse);
	let modeOptions = getModeOptionsForDisplay(startedParse);
	showModeOptions(modeOptions);
}

function parseMetaData(file) {
	let metaData = parseMainMetaDataTags(file);
	metaData["BPMS"] = parseBPMS(metaData["BPMS"]);
	parseNumericalTags(metaData);
	metaData["NOTES"] = parseModesAndDifficulties(file);
	return metaData;
}

function parseMainMetaDataTags(file) {
	// match any metadata tag excluding the "NOTES" tag (case-insensitive)
	let re = /#(?![nN][oO][tT][eE][sS])([^:]+):([^;]+);/g;
	let matches = [...file.matchAll(re)];
	let metaData = {};
	for(let i = 0; i < matches.length; i++) {
		let match = matches[i];
		metaData[cleanMetaDataString(match[1]).toUpperCase()] = cleanMetaDataString(match[2]);
	}
	return metaData;
}

function parseBPMS(bpmString) {
	let bpmArray = bpmString.split(",").map(e => e.trim().split("="));
	let bpms = [];
	for(let i = 0; i < bpmArray.length; i++) {
		bpms.push({beat: parseFloat(bpmArray[i][0]), bpm: parseFloat(bpmArray[i][1])});
	}
	return bpms;
}

function parseNumericalTags(metaData) {
	metaData["OFFSET"] = parseFloat(metaData["OFFSET"]);
	if(metaData["SAMPLELENGTH"]) {
		metaData["SAMPLELENGTH"] = parseFloat(metaData["SAMPLELENGTH"]);
	}
	if(metaData["SAMPLESTART"]) {
		metaData["SAMPLESTART"] = parseFloat(metaData["SAMPLESTART"]);
	}
}

function parseModesAndDifficulties(file) {
	// Get "NOTES" sections (case-insensitive). The first five values are postfixed with a colon.
	// Note data comes last, postfixed by a semicolon.
	let re = /#[nN][oO][tT][eE][sS]:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^;]+;)/g;
	let matches = [...file.matchAll(re)];
	let modesAndDifficulties = [];
	let fieldNames = ["type", "desc/author", "difficulty", "meter", "radar"]
	for(let i = 0; i < matches.length; i++) {
		let match = matches[i];
		let mode = {};
		for(let j = 1; j < match.length-1; j++) {
			mode[fieldNames[j-1]] = cleanMetaDataString(match[j]);
		}
		mode["notes"] = match[match.length - 1];
		modesAndDifficulties.push(mode);
	}
	return modesAndDifficulties;
}

function cleanMetaDataString(string) {
	return string.trim().replace(/\n/g,"");
}

function getModeOptionsForDisplay(metaData) {
	let modes = metaData["NOTES"];
	let modeOptions = [];
	for(let i = 0; i < modes.length; i++) {
		let mode = modes[i];
		modeOptions.push({type: mode["type"], difficulty: mode["difficulty"], meter: mode["meter"], id: i});
	}
	modeOptions.sort(compareModeOptions);
	return modeOptions;
}

function compareModeOptions(a, b) {
	let typeA = a.type.toUpperCase();
	let typeB = b.type.toUpperCase();
	if (typeA != typeB) {
		if(typeA < typeB) {
			return -1;
		}
		else {
			return 1;
		}
	}
	else {
		let difficultyA = a.difficulty.toUpperCase();
		let difficultyB = b.difficulty.toUpperCase();
		if(difficultyA != difficultyB) {
			return difficultyRank(difficultyA) - difficultyRank(difficultyB);
		}
		else {
			let meterA = parseFloat(a.meter);
			let meterB = parseFloat(b.meter);
			if(meterA != meterB) {
				return meterA - meterB;
			}
		}
	}
	return a.id = b.id;
}

function difficultyRank(difficulty) {
	switch(difficulty) {
		case "BEGINNER":
			return 0
		case "EASY":
			return 1;
		case "MEDIUM":
			return 2;
		case "HARD":
			return 3;
		case "CHALLENGE":
			return 4;
		case "EDIT":
			return 5;
		default:
			return 6;
	}
}

function showModeOptions(modeOptions) {
	let modeSelect = document.getElementById("finish-parse-section");
	let html = 'Choose a mode: <select id="mode-select">\n' +
		'<option hidden disabled selected value></option>\n';
	for(let i = 0; i < modeOptions.length; i++) {
		let mode = modeOptions[i];
		html += '<option value="' + mode["id"] + '">' +
			mode["type"] + ', ' + mode["difficulty"] + ', ' + mode["meter"] +
			'</option>\n';
	}
	html += '</select><br>\n';
	html += getFinishParseButton();
	modeSelect.innerHTML = html;
}

function getFinishParseButton() {
	return '<input type="button" value="Finish Parse" onclick="finishParse()"><br>';
}

function finishParse() {
	let selectedMode = document.getElementById("mode-select").value;
	let unparsedNotes = startedParse["NOTES"][selectedMode]["notes"];
	let unparsedArray = unparsedNotes.split("\n");
	let measures = getMeasures(unparsedArray);
	let beatsAndLines = getBeatInfoByLine(measures);
	let timesBeatsAndLines = getTimeInfoByLine(beatsAndLines, startedParse["OFFSET"], startedParse["BPMS"]);
	console.log(measures);
	console.log(beatsAndLines);
	console.log(timesBeatsAndLines);
}

function getMeasures(unparsedArray) {
	let measures = [];
	let state = 0;
	let i = 0;
	let currentMeasure = [];
	while(i < unparsedArray.length) {
		let currentLine = unparsedArray[i];
		switch(state) {
			case 0:
				if(!currentLine.includes("//") && currentLine.trim() !== "") {
					state = 1;
				}
				else {
					i++;
				}
				break;
			case 1:
				if(!currentLine.includes(",") && !currentLine.includes(";") && currentLine.trim() !== "") {
					currentMeasure.push(currentLine.trim());
					i++;
				}
				else {
					state = 2;
				}
				break;
			case 2:
				measures.push(currentMeasure);
				currentMeasure = [];
				i++;
				state = 0;
				break;
		}
	}
	return measures;
}

// assumes 4/4 time signature
// TODO: avoid adding fractional beats together?
function getBeatInfoByLine(measures) {
	beatsAndLines = [];
	let currentBeat = 0;
	for(let i = 0; i < measures.length; i++) {
		let measure = measures[i];
		for(let j = 0; j < measure.length; j++) {
			beatsAndLines.push({beat: currentBeat, lineInfo: measure[j]});
			currentBeat += 4 / measure.length;
		}
	}
	return beatsAndLines;
}

function getTimeInfoByLine(infoByLine, offset, bpms) {
	let currentTime = -offset;
	infoByLine[0].time = currentTime;
	for(let i = 1; i < infoByLine.length; i++) {
		let startBeat = infoByLine[i-1].beat;
		let endBeat = infoByLine[i].beat;
		currentTime += getElapsedTime(startBeat, endBeat, bpms);
		infoByLine[i].time = currentTime;
	}
	return infoByLine;
}

function getElapsedTime(startBeat, endBeat, bpms) {
	let currentBPMIndex = getStartBPMIndex(startBeat, bpms);
	let earliestBeat = startBeat;
	let elapsedTime = 0;
	do {
		let nextBPMChange = getNextBPMChange(currentBPMIndex, bpms);
		let nextBeat = Math.min(endBeat, nextBPMChange);
		elapsedTime += (nextBeat - earliestBeat) / bpms[currentBPMIndex].bpm * 60;
		earliestBeat = nextBeat;
		currentBPMIndex++;
	} while(earliestBeat < endBeat);
	return elapsedTime;
}

function getStartBPMIndex(startBeat, bpms) {
	let startBPMIndex = 0;
	for(let i = 1; i < bpms.length; i++) {
		if(bpms[i].beat < startBeat) {
			startBPMIndex = i;
		}
	}
	return startBPMIndex;
}

function getNextBPMChange(currentBPMIndex, bpms) {
	if(currentBPMIndex + 1 < bpms.length) {
		return bpms[currentBPMIndex + 1].beat;
	}
	return Number.POSITIVE_INFINITY;
}
</script>
</html>